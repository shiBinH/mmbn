<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="scripts/three.min.js"></script>
		<script src="scripts/OrbitControls.js"></script>
		<script>
			var geometry, material, mesh;
			var map;
			
			// Our Javascript will go here.
			
			map = {};
			
			//	camera, scene
			var scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0f3066);
			var camera = new THREE.PerspectiveCamera( 30, window.innerWidth/window.innerHeight, 0.1, 1000);

			//	var camera = new THREE.OrthographicCamera(-30, 30, 30, -30, 1, 500);
			var gridHelper = new THREE.GridHelper(100, 10, 'blue')
			gridHelper.rotateX(Math.PI/2)
			scene.add(gridHelper)
			gridHelper = new THREE.GridHelper(100, 10, 'blue');
			gridHelper.translateX(-50);
			gridHelper.rotateZ(-Math.PI/2)
			scene.add(gridHelper)
			
			
			var ambient = new THREE.AmbientLight(new THREE.Color('white'), 0);
			scene.add(ambient)
			var directional = new THREE.DirectionalLight(0xffff00, 0);
			//	directional.castShadow = true;
			scene.add(directional)
			var hemisphere = new THREE.HemisphereLight( new THREE.Color('white'), 1);
			scene.add( hemisphere );
			var point = new THREE.PointLight( new THREE.Color('white'), 1);
			point.visible = false
			point.castShadow = true;
			point.position.set( 0, 0, 50 );
			scene.add(point);

			
			//	add renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
			//	planes
			geometry = new THREE.PlaneGeometry(100, 100, 0, 0)
			material = new THREE.MeshStandardMaterial({color: new THREE.Color('white')});
			var plane = new THREE.Mesh(geometry, material);
			plane.receiveShadow = true;
			scene.add(plane)
			geometry = new THREE.PlaneGeometry(100, 100, 0, 0)
			material = new THREE.MeshStandardMaterial({color: new THREE.Color('white')});
			plane = new THREE.Mesh(geometry, material);
			plane.receiveShadow = true;
			plane.translateX(-50);
			plane.rotateY(Math.PI/2)
			scene.add(plane)

			
			//	box
			var texture = new THREE.TextureLoader().load( "images/circle.png" );
			geometry = new THREE.CubeGeometry(10, 10, 10);
			//	material = new THREE.MeshStandardMaterial({color: new THREE.Color('yellow')});
			material = new THREE.MeshStandardMaterial({map: texture})
			var box = new THREE.Mesh(geometry, material);
			box.castShadow = true;
			box.position.set(30, 30, 5)
			scene.add(box);
			
			//	sphere
			
			//texture.wrapS = THREE.RepeatWrapping;
			//texture.wrapT = THREE.RepeatWrapping;
			//texture.repeat.set( 1, 1 );
			geometry = new THREE.SphereGeometry( 2 );
			material = new THREE.MeshLambertMaterial ({color: new THREE.Color('green')});
			var main = new THREE.Mesh( geometry, material );
			main.castShadow = true;
			main.receiveShadow = true;
			main.position.set(5, 5, 1)
			main.quaternion = new THREE.Quaternion(0, 0, 1, 0)
			
			scene.add( main );
			
			//	bones
			var leg = new THREE.Bone();
			var knee = new THREE.Bone();
			var ankle = new THREE.Bone();
			var foot = new THREE.Bone();
			leg.add(knee) ; knee.add(ankle) ; ankle.add(foot);
			
			var bones1 = [leg, knee, ankle, foot];
			var legSkeleton = new THREE.Skeleton(bones1);
			//var bones1 = [start, middle, end];
			
			/*
			start.add(middle);
			middle.add(end);
			start.position.y = 2;
			end.position.y = -2;
			var bones1 = [];
			bones1.push(start); bones1.push(middle); bones1.push(end);
			var legSkeleton = new THREE.Skeleton(bones1);
			geometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 9);
			for (var i=0 ; i<geometry.vertices.length ; i++) {
				if (i<geometry.vertices.length/2) {
					geometry.skinIndices.push(new THREE.Vector4(0, 1, 2, 0))
					geometry.skinWeights.push(new THREE.Vector4(.7, .3, 0, 0));
				} else {
						geometry.skinIndices.push(new THREE.Vector4(0, 1, 2, 0))
						geometry.skinWeights.push(new THREE.Vector4(0, 0.3, 0.7, 0));
				}
			}
			material = new THREE.MeshStandardMaterial({skinning: true, color: 0x33adff});
			mesh = new THREE.SkinnedMesh(geometry, material);
			mesh.add(legSkeleton.bones[0]);
			mesh.bind(legSkeleton);
			mesh.position.z = 10;
			mesh.castShadow = true;
			mesh.rotateX(Math.PI/2)
			scene.add(mesh)
			
			var helper = new THREE.SkeletonHelper( mesh );
			helper.material.linewidth = 3;
			scene.add( helper );
			*/
			
			//	movement, action
			
			var prevTime = performance.now();
			var movingLeft = false,
					movingRight = false,
					movingUp = false,
					movingDown = false,
					airborne = false;
			var velocity = new THREE.Vector3();
			
			$(window).on('keydown', function(e) {
				var key = e.keyCode;
				//	console.log(key)
				switch (key) {
					case 70:
						movingLeft = true;
						break;
					case 72:
						movingRight = true;
						break;
					case 84:
						movingUp = true; break;
					case 71:
						movingDown = true;
						break;
					case 90:
						if (!airborne) {
							velocity.z += 100;
							airborne = true;
						}
						break;
					case 192:
						map[192] = true;
						break;
					case 81:
						if (map[192]) ambient.intensity = Math.max (0, ambient.intensity-0.1)
						else ambient.intensity = Math.min(3, ambient.intensity+0.1)
						console.log("ambient: " + ambient.intensity.toFixed(1))
						break;
					case 87:
						if (map[192]) directional.intensity = Math.max(0, directional.intensity-0.1)
						else directional.intensity = Math.min(3, directional.intensity+0.1)
						console.log("directional: " + directional.intensity.toFixed(1))
						break;
					case 50:
						if (point.visible) point.visible = false;
						else point.visible = true;
						break;
					case 49:
						if (map[192]) hemisphere.intensity = Math.max(0, hemisphere.intensity-0.1);
						else hemisphere.intensity = Math.min(3, hemisphere.intensity+0.1)
						console.log('hemisphere: ' + hemisphere.intensity.toFixed(1))
				}
			})
			$(window).on('keyup', function(e) {
				var key = e.keyCode;
				switch (key) {
					case 70:
						movingLeft = false;
						velocity.x = 0;
						break;
					case 72:
						movingRight = false;
						velocity.x = 0;
						break;
					case 84:
						movingUp = false;
						velocity.y = 0;
						break;
					case 71:
						movingDown = false;
						velocity.y = 0;
						break;
					case 90:
						velocity.z = Math.min(velocity.z, 0)
						break;
					case 192:
						map[192] = false;
						break;
				}
			})
			
			var track = new THREE.QuaternionKeyframeTrack('cube.quaternion', new Float32Array([
				0, 2, 4, 6, 8
			]), [
				0, 0, 0, 1, 0, 0, 1/Math.sqrt(2), 1/Math.sqrt(2), 0, 0, 1, 0, 0, 0, 1/Math.sqrt(2), -1/Math.sqrt(2), 0, 0, 0, -1
			])
			var track2 = new THREE.NumberKeyframeTrack('rotation.z', new Float32Array([
				0, 2, 4, 6, 8
			]), [
				0, Math.PI/2, Math.PI, Math.PI*3/2, Math.PI*2
			])
			var clip = new THREE.AnimationClip('test', 8, [track]);
			var mixer = new THREE.AnimationMixer(box);
			var action = mixer.clipAction(clip)
			//	action.zeroSlopeAtStart = action.zeroSlopeAtEnd = false;
			//	action.setLoop(THREE.LoopPingPong, 0)
			console.log(mixer)
			action.play()
			
			
			render();

			function render() {
				var g = 300;
				velocity.x = 20;
				velocity.y = 20;
				
				camera.position.copy(main.position);
				camera.position.z += 50;
				camera.position.x += 50;
				camera.position.y -= 50;
				camera.up.set(0, 0, 1)
				camera.lookAt(main.position);
				
				var time = performance.now();
				var delta = (time - prevTime) / 1000;
				
				mixer.update(delta)
				
				if (movingLeft) velocity.x *= -1;
				if (movingDown) velocity.y *= -1;
				if (movingLeft || movingRight) {
					main.translateX( velocity.x * delta);
					main.translateY(velocity.x * delta)
				}
				if (movingDown || movingUp) {
					main.translateY(velocity.y * delta);
					main.translateX(velocity.y * -delta)
				}
			
				velocity.z -= g * delta;
				main.translateZ(velocity.z * delta)
				if (main.position.z - 2 < 0) {
					velocity.z = 0;
					main.position.z = 2;
					airborne = false;
				}
				
				
				prevTime = time;
				
				renderer.render( scene, camera );
				requestAnimationFrame( render );
			}
			
		</script>
	</body>
</html>